# 0.2 动态规划

参考：

[五大常用算法之二：动态规划算法](https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741374.html)

[数据结构与算法基础——动态规划（Dynamic programming）](http://cxy7.com/articles/2018/07/31/1533027897027.html)

[算法-动态规划](https://blog.csdn.net/u013309870/article/details/75193592)



目录：

[TOC]

# 一、基础概念

## 1.1 定义

动态规划过程是：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。



## 1.2 思想与策略

基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。

由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。

与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。



# 二、主要性质



## 2.1最优子结构

如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。



## 2.2无后效性

即子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。



## 2.3重叠子问题

子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率。



在递归求解问题时，往往会对同一个子问题反复求解，这样会造成时间复杂度的增加，为了减少重复计算，可以利用一个哈希表暂存中间子问题的解，这样在后续计算时可以先检查缓存，如果已经计算过，就不必再次计算。



# 三、动态规划的解法

动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。

动态规划的本质，是对问题状态的定义和状态转移方程的定义。

##3.1 状态

计算机的本质是一个状态机，内存里存储的所有数据构成了当前的状态，CPU只能利用当前的状态计算出下一个状态（不要纠结硬盘之类的外部存储，就算考虑他们也只是扩大了状态的存储容量而已，并不能改变下一个状态只能从当前状态计算出来这一条铁律）

当你企图使用计算机解决一个问题时，其实就是在思考如何将这个问题表达成状态（用哪些变量存储哪些数据）以及如何在状态中转移（怎样根据一些变量计算出另一些变量）。所以所谓的空间复杂度就是为了支持你的计算所必需存储的状态最多有多少，所谓时间复杂度就是从初始状态到达	最终状态中间需要多少步！

一个问题是该用递推、贪心、搜索还是动态规划，完全是由这个问题本身阶段间状态的转移方式决定的！

1. 每个阶段只有一个状态->递推
2. 每个阶段的最优状态都是由上一个阶段的最优状态得到的->贪心
3. 每个阶段的最优状态是由之前所有阶段的状态的组合得到的->搜索
4. 每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的->动态规划

在递归求解问题时，往往会对同一个子问题反复求解，这样会造成时间复杂度的增加，为了减少重复计算，可以利用一个哈希表暂存中间子问题的解，这样在后续计算时可以先检查缓存，如果已经计算过，就不必再次计算。



## 3.2 状态转移方程

状态和状态之间的关系式，就叫做状态转移方程。描述了原问题的解如何由子问题的解组合而成



## 3.3 备忘录/空间换时间 

在递归求解问题时，往往会对同一个子问题反复求解，这样会造成时间复杂度的增加，为了减少重复计算，可以利用一个哈希表暂存中间子问题的解，这样在后续计算时可以先检查缓存，如果已经计算过，就不必再次计算。



## 3.4三个特点

1. 把原来的问题分解成了几个相似的子问题。（强调“相似子问题”）
2. 所有的子问题都只需要解决一次。（强调“只解决一次”）
3. 储存子问题的解。（强调“储存”）



## 3.5 动态规划的实现方法



### “自顶向下”（top-down dynamic programming）

1. 能方便的得到递归公式，并用递归函数实现
2. 保持了递归实现的代码结构，逻辑上容易理解。
3. 过程中只计算需要计算的子结果。
4. 当采用了caching技术时多次被调用时天然的复用之前被调用时的子结果。（比如连续两次计算fibonacci数F(4), F(5),则计算F(5)时已知F(3)和F(4)，直接相加即可）



### “自低向上”（bottom-up dynamic programming）

1. 需要设计数据结构来完成自底向上的计算过程。逻辑上相对不那么直观。
2. 常常可以进行空间复杂度的优化。比如Fibonacci数列可以优化为只使用两个变量的额外存储空间，0-1背包问题可以优化为O(n)的空间复杂度。
3. 若进行了空间优化，则连续多次被调用时无法复用之前被调用的子结果。



## 3.6解题步骤

1. 描述最优解的结构
2. 递归定义最优解的值
3. 按自底向上的方式计算最优解的值
4. 由计算出的结果构造一个最优解



# 四、经典模型

## 4.1 线性模型

【例题1】在一个夜黑风高的晚上，有n（n <= 50）个小朋友在桥的这边，现在他们需要过桥，但是由于桥很窄，每次只允许不大于两人通过，他们只有一个手电筒，所以每次过桥的两个人需要把手电筒带回来，i号小朋友过桥的时间为T[i]，两个人过桥的总时间为二者中时间长者。问所有小朋友过桥的总时间最短是多少。



每次过桥的时候最多两个人，如果桥这边还有人，那么还得回来一个人（送手电筒），也就是说N个人过桥的次数为2*N-3（倒推，当桥这边只剩两个人时只需要一次，三个人的情况为来回一次后加上两个人的情况…）。有一个人需要来回跑，将手电筒送回来（也许不是同一个人，realy？！）这个回来的时间是没办法省去的，并且回来的次数也是确定的，为N-2，如果是我，我会选择让跑的最快的人来干这件事情，但是我错了…如果总是跑得最快的人跑回来的话，那么他在每次别人过桥的时候一定得跟过去，于是就变成就是很简单的问题了，花费的总时间：

T = minPTime * (N-2) + (totalSum-minPTime)

来看一组数据 四个人过桥花费的时间分别为 1 2 5 10，按照上面的公式答案是19，但是实际答案应该是17。

具体步骤是这样的：

第一步：1和2过去，花费时间2，然后1回来（花费时间1）；

第二歩：3和4过去，花费时间10，然后2回来（花费时间2）；

第三部：1和2过去，花费时间2，总耗时17。

所以之前的贪心想法是不对的。我们先将所有人按花费时间递增进行排序，假设前i个人过河花费的最少时间为opt[i]，那么考虑前i-1个人过河的情况，即河这边还有1个人，河那边有i-1个人，并且这时候手电筒肯定在对岸，所以opt[i] = opt[i-1] + a[1] + a[i] (让花费时间最少的人把手电筒送过来，然后和第i个人一起过河)如果河这边还有两个人，一个是第i号，另外一个无所谓，河那边有i-2个人，并且手电筒肯定在对岸，所以opt[i] = opt[i-2] + a[1] + a[i] + 2*a[2] (让花费时间最少的人把电筒送过来，然后第i个人和另外一个人一起过河，由于花费时间最少的人在这边，所以下一次送手电筒过来的一定是花费次少的，送过来后花费最少的和花费次少的一起过河，解决问题) 



所以 opt[i] = min{opt[i-1] + a[1] + a[i] , opt[i-2] + a[1] + a[i] + 2*a[2] }



## 4.2 区间模型

区间模型的状态表示一般为d[i][j]，表示区间[i, j]上的最优解，然后通过状态转移计算出[i+1, j]或者[i, j+1]上的最优解，逐步扩大区间的范围，最终求得[1, len]的最优解。

【例题2】给定一个长度为n（n <= 1000）的字符串A，求插入最少多少个字符使得它变成一个回文串。 
典型的区间模型，回文串拥有很明显的子结构特征，即当字符串X是一个回文串时，在X两边各添加一个字符’a’后，aXa仍然是一个回文串，我们用d[i][j]来表示A[i…j]这个子串变成回文串所需要添加的最少的字符数，那么对于A[i] == A[j]的情况，很明显有 d[i][j] = d[i+1][j-1] （这里需要明确一点，当i+1 > j-1时也是有意义的，它代表的是空串，空串也是一个回文串，所以这种情况下d[i+1][j-1] = 0）；当A[i] != A[j]时，我们将它变成更小的子问题求解，我们有两种决策：

1、在A[j]后面添加一个字符A[i]；

2、在A[i]前面添加一个字符A[j]；

根据两种决策列出状态转移方程为：

d[i][j] = min{ d[i+1][j], d[i][j-1] } + 1; (每次状态转移，区间长度增加1)



空间复杂度O(n^2)，时间复杂度O(n^2)， 下文会提到将空间复杂度降为O(n)的优化算法。



## 4.3 背包模型

背包问题是动态规划中一个最典型的问题之一。由于网上有非常详尽的背包讲解，这里只将常用部分抽出来。

【例题3】有N种物品（每种物品1件）和一个容量为V的背包。放入第 i 种物品耗费的空间是Ci，得到的价值是Wi。求解将哪些物品装入背包可使价值总和最大。f[i][v]表示前i种物品恰好放入一个容量为v的背包可以获得的最大价值。决策为第i个物品在前i-1个物品放置完毕后，是选择放还是不放，状态转移方程为：

f[i][v] = max{ f[i-1][v], f[i-1][v – Ci] +Wi }



时间复杂度O(VN)，空间复杂度O(VN) （空间复杂度可利用滚动数组进行优化达到O(V) ）。



# 五、与其他算法的关联



##5.1动态规划与贪心算法的区别

动态规划以自底向上的方式来利用最优子结构。也就是说，首先找到子问题的最优解，解决的子问题，然后找到问题的一个最优解。寻找问题的一个最优解需要首先在子问题中做出选择，即选择用哪一个来求解问题。问题解的代价通常是子问题的代价加上选择本身带来的开销。

在贪心算法中是以自顶向下的方式使用最优子结构。贪心算法会先做选择，在当时看来是最优的选择，然后在求解一个结果子问题，而不是现寻找子问题的最优解，然后再做选择。



##5.2与分治法的区别

分治法是将问题分解为一些独立的子问题，递归的求解各个子问题，然后合并子问题的解而得到源问题的解。

而动态规划适合用于子问题不是独立的情况，也就是各个子问题包含公共的子子问题。在这种情况下，若采用分治的的思想则会做许多不必要的工作。动态规划会对每个子子问题之求解一次，将其结果保存在一张表中，从而避免每次遇到各个子问题时重新计算答案。

计算机的本质是一个状态机，内存里存储的所有数据构成了当前的状态，CPU只能利用当前的状态计算出下一个状态（不要纠结硬盘之类的外部存储，就算考虑他们也只是扩大了状态的存储容量而已，并不能改变下一个状态只能从当前状态计算出来这一条铁律）

当你企图使用计算机解决一个问题时，其实就是在思考如何将这个问题表达成状态（用哪些变量存储哪些数据）以及如何在状态中转移（怎样根据一些变量计算出另一些变量）。所以所谓的空间复杂度就是为了支持你的计算所必需存储的状态最多有多少，所谓时间复杂度就是从初始状态到达最终状态中间需要多少步！

一个问题是该用递推、贪心、搜索还是动态规划，完全是由这个问题本身阶段间状态的转移方式决定的！

1. 每个阶段只有一个状态->递推
2. 每个阶段的最优状态都是由上一个阶段的最优状态得到的->贪心
3. 每个阶段的最优状态是由之前所有阶段的状态的组合得到的->搜索
4. 每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的->动态规划
